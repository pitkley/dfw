# Below you'll find an example configuration, showing you and explaining most
# (if not all) possible configurations you might need. If you are unsure about
# any of the explanations, be sure to also check out the documentation on the
# internal types that are configured through this TOML file:
#
#   https://docs.rs/dfw/*/dfw/types/index.html
#
# Each of the sections in this file matches to a struct under the same name,
# and every struct field contains some documentation that might help you out.

[defaults]
# Define the external network interface(s) that the Docker networks should be
# able to communicate with. (You can also skip this key, or specify it as a
# list of strings if you have multiple interfaces.)
external_network_interfaces = "eth0"

[initialization]
# The initialization table allows you to define some basic rules that you want
# added to the IPv4 or IPv6 iptables, in addition to the rules generated by
# DFW.

[initialization.v4]
# The key-name identifies the iptables table you want to add the rules to (i.e.
# `filter`, `nat`, `mangle` or even `raw`). The value should be a list of
# strings, where each string is an iptables rule you want added.
filter = [
    "-P INPUT DROP",
]

[container_to_container]
# The container_to_container table defines if and how containers are allowed to
# communicate amongst each other. The first thing you have to define is the
# default policy that should be applied to C2C communication, e.g. disallow all
# communication by default:
default_policy = "DROP"

[[container_to_container.rules]]
# To then allow specific communication between containers, you'll have to add a
# rule defining this communication. For example the following configuration
# will allow all communication between the containers `container_a` and
# `container_b`, as long as the containers are able to communicate via the
# Docker network `common_network`.
network = "common_network"
src_container = "container_a"
dst_container = "container_b"
action = "ACCEPT"
# (If you want to enable communication between two containers that are on
# separate Docker networks, check out the container_dnat section at the end of
# the file.)

[[container_to_container.rules]]
# The `src_container` and `dst_container` fields are both optional, and you are
# allowed to specify both, none, or either one. This enables you to for example
# configure the allowed communication on a complete Docker network, no matter
# the containers involved:
network = "internal_network"
action = "ACCEPT"

[[container_to_container.rules]]
# Being able to specify only one of `src_container` and `dst_container` can be
# useful in many cases. One example could be a reverse-proxy: you want your
# proxying container to be able to access any other container on the same
# reverse-proxy network, without the other containers being able to access each
# other or the proxying container (except for the responses to requests made by
# the reverse proxy, i.e. related and established traffic will be allowed):
network = "reverseproxy_network"
src_container = "my_reverseproxy"
action = "ACCEPT"

[[container_to_container.rules]]
# If the simple iptables actions (ACCEPT, REJECT, DROP) are not enough for your
# use-case, you can also specify the `filter` field which will add your
# specified string to the iptables command executed. This enables you to for
# example set a specific destination port that should be reachable, rather than
# the container as a whole:
network = "reverseproxy_network"
src_container = "my_reverseproxy"
dst_container = "my_webserver"
filter = "-p tcp --dport 8080"
action = "ACCEPT"

[container_to_wider_world]
# The container_to_wider_world table defines if and how containers should be
# able to communicate with the wider world, i.e. communications across the
# iptables `OUTPUT` chain. (Communications with the host are handled
# separately, see the next section.) This table expects a default policy, i.e.
# if you want to allow or block traffic to the wider world by default. If your
# containers should be able to reach the internet, you'll probably want to set
# this to ACCEPT.
default_policy = "ACCEPT"

[[container_to_wider_world.rules]]
# The container_to_wider_world rules work very similar to the
# container_to_container ones, except for one major change: there is no
# destination container, but rather the external network interface the source
# network/container should be able to communicate with. So if you want to e.g.
# block a specific Docker network from accessing resources on `eth0`, you can
# do this:
network = "internal_network"
action = "REJECT"
external_network_interface = "eth0"

[[container_to_wider_world.rules]]
# If you don't define the `external_network_interface`, DFW will by default use
# the (first) external network interface you have defined in the "defaults"
# section of this config, in this case `eth0`. This means that the following
# rule is identical to the one above:
network = "internal_network"
action = "REJECT"

# Note: you are also free to specify the `src_container` and `filter` fields
# here. Their behaviour is identical to what was shown for the C2C rules.

[container_to_host]
# The container_to_host table lets you configure if you want your containers to
# be able to communicate with the Docker host itself or not. Again, we expect a
# default policy:
default_policy = "ACCEPT"

[[container_to_host.rules]]
# And as with container_to_container and container_to_wider_world before, you
# can specify additional rules. You are required to provide the `network` and
# `action` keys, and are allowed to also specify the `src_container` and an
# additional `filter`, as with the other types of rules, too.
network = "internal_network"
action = "REJECT"

[wider_world_to_container]
# The last section you'll probably need -- and this is maybe the most important
# one -- is wider_world_to_container. This allows you to specify what resources
# the wider world should be able to access from your Docker containers, i.e.
# allowing connections to the ports and thus services running in your Docker
# containers. This section does NOT allow you to specify a default policy, it
# is expected that you manually allow all services you require.

[[wider_world_to_container.rules]]
# To configure access to some resource from the wider world, you'll need to
# specify the Docker network and container that should be accessible.
# Furthermore you need to specify the port that the service in the container
# listens to, as well as the port that should be used to publish this service
# on the host.
network = "reverseproxy_network"
dst_container = "my_reverseproxy"
expose_port = { host_port = 80, container_port = 80, family = "tcp" }

# Specifying the port like this is relatively long-winded, especially if the
# host and container port are identical. To work around this, you have multiple
# other methods of doing the same thing (from least verbose to most verbose):
#
#   expose_port = 80
#   expose_port = "80/tcp"
#   expose_port = { host_port = 80 }
#   expose_port = { host_port = 80, family = "tcp" }
#   expose_port = { host_port = 80, container_port = 80 }
#   expose_port = { host_port = 80, container_port = 80, family = "tcp" }
#
# All of these are identical, where the `family` is by default assumed to be
# TCP, and the container port is assumed to be identical to the host port.

[[wider_world_to_container.rules]]
# Sometimes, you might also want to allow access to multiple ports from a
# single container. This is also possible:
network = "reverseproxy_network"
dst_container = "my_reverseproxy"
expose_port = [80, 443]

# If the container ports are different from the host ports, you can still
# define multiple at once:
#
#   expose_port = [
#       { host_port = 80, container_port = 8080 },
#       { host_port = 443, container_port = 80443 },
#   ]

[[wider_world_to_container.rules]]
# A final thing: the WW2C rules require the external network interface to be
# specified, for which the host-port will be forwarded to the container. By
# default this is again the primary (i.e. the first) external network interface
# as specified in the "defaults" section, but you can override this here:
network = "reverseproxy_network"
dst_container = "my_reverseproxy"
expose_port = [80, 443]
external_network_interface = "tun0"

[container_dnat]
# Finally, the actual last section and one you might only need in very special
# cases, is container_dnat. This section allows you to prohibit or allow
# communication between containers that DO NOT share a Docker network. (There
# is no default policy.)

[[container_dnat.rules]]
# You can use this section to for example allow any container to access some
# central container, like a log-collection target. (This rule shows all
# required fields.)
dst_network = "log_network"
dst_container = "logstash"
expose_port = 5044

[[container_dnat.rules]]
# Alternatively you can specify that one specific container can access another
# specific container, across networks. (This rule shows all fields, including
# optional ones.)
src_network = "network_a"
src_container = "container_a"
dst_network = "network_b"
dst_container = "container_b"
expose_port = "50000/udp"

